var documenterSearchIndex = {"docs":
[{"location":"#Peaks.jl","page":"Peaks.jl","title":"Peaks.jl","text":"","category":"section"},{"location":"","page":"Peaks.jl","title":"Peaks.jl","text":"argmaxima\nargminima\nmaxima\nminima\nfindmaxima\nfindminima\npeakproms\npeakproms!\npeakwidths\npeakwidths!\npeakheights\npeakheights!\nfilterpeaks!\nfindnextmaxima\nfindnextminima\nismaxima\nisminima","category":"page"},{"location":"#Peaks.argmaxima","page":"Peaks.jl","title":"Peaks.argmaxima","text":"argmaxima(x[, w=1; strict=true]) -> Vector{Int}\n\nFind the indices of local maxima in x, where each maxima i is either the maximum of x[i-w:i+w] or the first index of a plateau.\n\nA plateau is defined as a maxima with consecutive equal (===/egal) maximal values which are bounded by lesser values immediately before and after the consecutive maximal values.\n\nWhen strict == true, no elements in x[i-w:i+w] may be missing or NaN, and the bounds of a plateau must exist. For strict == false, a maxima is the maximum of all non-NaN or missing elements in x[i-w:i+w], and plateau bounds are assumed to exist (i.e. missing, NaN, or either end of the array, x[begin-1] or x[end+1], may be treated as the bounds of a plateau).\n\nSee also: findmaxima, findnextmaxima\n\nExamples\n\njulia> argmaxima([0,2,0,1,1,0])\n2-element Vector{Int64}:\n 2\n 4\n\njulia> argmaxima([2,0,1,1])\nInt64[]\n\njulia> argmaxima([2,0,1,1]; strict=false)\n2-element Vector{Int64}:\n 1\n 3\n\n\n\n\n\n","category":"function"},{"location":"#Peaks.argminima","page":"Peaks.jl","title":"Peaks.argminima","text":"argminima(x[, w=1; strict=false]) -> Vector{Int}\n\nFind the indices of local minima in x, where each minima i is either the minimum of x[i-w:i+w] or the first index of a plateau.\n\nA plateau is defined as a minima with consecutive equal (===/egal) minimal values which are bounded by greater values immediately before and after the consecutive minimal values.\n\nWhen strict == true, no elements in x[i-w:i+w] may be missing or NaN, and the bounds of a plateau must exist. For strict == false, a minima is the minimum of all non-NaN or missing elements in x[i-w:i+w], and plateau bounds are assumed to exist (i.e. missing, NaN, or either end of the array, x[begin-1] or x[end+1], may be treated as the bounds of a plateau).\n\nSee also: findminima, findnextminima\n\nExamples\n\njulia> argminima([3,2,3,1,1,3])\n2-element Vector{Int64}:\n 2\n 4\n\njulia> argminima([2,3,1,1])\nInt64[]\n\njulia> argminima([2,3,1,1]; strict=false)\n2-element Vector{Int64}:\n 1\n 3\n\n\n\n\n\n","category":"function"},{"location":"#Peaks.maxima","page":"Peaks.jl","title":"Peaks.maxima","text":"maxima(x[, w=1; strict=true]) -> Vector{eltype(x)}\n\nFind the values of local maxima in x, where each maxima i is either the maximum of x[i-w:i+w] or the first index of a plateau.\n\nA plateau is defined as a maxima with consecutive equal (===/egal) maximal values which are bounded by lesser values immediately before and after the consecutive maximal values.\n\nSee also: argmaxima, findnextmaxima\n\n\n\n\n\n","category":"function"},{"location":"#Peaks.minima","page":"Peaks.jl","title":"Peaks.minima","text":"minima(x[, w=1; strict=true]) -> Vector{eltype(x)}\n\nFind the values of local minima in x, where each minima i is either the minimum of x[i-w:i+w] or the first index of a plateau.\n\nA plateau is defined as a minima with consecutive equal (===/egal) minimal values which are bounded by greater values immediately before and after the consecutive minimal values.\n\nSee also: argminima, findnextminima\n\n\n\n\n\n","category":"function"},{"location":"#Peaks.findmaxima","page":"Peaks.jl","title":"Peaks.findmaxima","text":"findmaxima(x[, w=1; strict=true]) -> (;indices, heights, data)\n\nFind the indices and values of local maxima in x, where each maxima i is either the maximum of x[i-w:i+w] or the first index of a plateau.\n\nReturns a NamedTuple contains the fields indices, heights, data, which are equivalent to heights = data[indices]. The data field is a reference (not a copy) to the argument x.\n\nA plateau is defined as a maxima with consecutive equal (===/egal) maximal values which are bounded by lesser values immediately before and after the consecutive maximal values.\n\nSee also: argmaxima, findnextmaxima\n\nExamples\n\njulia> data = [1, 5, 1, 3, 2];\n\njulia> pks = findmaxima(data)\n(indices = [2, 4], heights = [5, 3], data = [1, 5, 1, 3, 2])\n\n\n\n\n\n","category":"function"},{"location":"#Peaks.findminima","page":"Peaks.jl","title":"Peaks.findminima","text":"findminima(x[, w=1; strict=true]) -> (;indices, heights, data)\n\nFind the indices and values of local minima in x, where each minima i is either the minimum of x[i-w:i+w] or the first index of a plateau.\n\nReturns a NamedTuple contains the fields indices, heights, data, which are equivalent to heights = data[indices]. The data field is a reference (not a copy) to the argument x.\n\nA plateau is defined as a minima with consecutive equal (===/egal) minimal values which are bounded by greater values immediately before and after the consecutive minimal values.\n\nSee also: argminima, findnextminima\n\nExamples\n\njulia> data = [1, 5, 1, 3, 2];\n\njulia> valleys = findminima(data)\n(indices = [3], heights = [1], data = [1, 5, 1, 3, 2])\n\n\n\n\n\n","category":"function"},{"location":"#Peaks.peakproms","page":"Peaks.jl","title":"Peaks.peakproms","text":"peakproms(indices, x; [strict=true, min, max]) -> (indices, proms)\npeakproms(pks::NamedTuple; [strict=true, min, max]) -> NamedTuple\n\nCalculate the prominences of peak indices in x, and remove peaks with prominences less than min and/or greater than max.\n\nPeak prominence is the absolute height (value) difference between the current peak and the larger of the two adjacent smallest magnitude points between the current peak and adjacent larger peaks or signal ends.\n\nIf a NamedTuple pks is given, a new NamedTuple is returned with filtered copies of fields from pks. pks must have :indices and :heights fields. If pks has a :proms field, prominences will only be filtered, and not be recalculated. The fields :widths and :edges will also be filtered if present, and any remaining fields will be copied unmodified.\n\nIf strict == true, the prominence for a peak with a NaN or missing between the current peak and either adjacent larger peaks will be NaN or missing, otherwise, it will be the larger of the smallest non-NaN or missing values between the current peak and adjacent larger peaks for strict == false.\n\nSee also: peakproms!, findmaxima\n\nExamples\n\njulia> pks = findmaxima([0,5,2,3,3,1,4,0]);\n\njulia> pks = peakproms(pks; min=2)\n(indices = [2, 7], heights = [5, 4], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[5, 3])\n\njulia> inds, proms = peakproms(pks.indices, pks.data; max=4)\n([7], Union{Missing, Int64}[3])\n\n\n\n\n\npeakproms(; [strict, min, max]) -> Function\n\nCreate a function, f(pks::NamedTuple), that calculates and filters the peak prominences of a copy of its argument, pks, using any given keyword arguments.\n\nExamples\n\njulia> findmaxima([0,5,2,3,3,1,4,0]) |> peakproms(; min=2)\n(indices = [2, 7], heights = [5, 4], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[5, 3])\n\n\n\n\n\n","category":"function"},{"location":"#Peaks.peakproms!","page":"Peaks.jl","title":"Peaks.peakproms!","text":"peakproms!(indices, x; [strict=true, min, max]) -> (indices, proms)\npeakproms!(pks::NamedTuple; [strict=true, min, max]) -> NamedTuple\n\nCalculate the prominences of peak indices in x, and remove peaks with prominences less than min and/or greater than max.\n\nIf a NamedTuple pks is given, a new NamedTuple is returned with the same fields (references) from pks. pks must have :indices and :heights fields. If pks has a :proms field, prominences will only be filtered, and not be recalculated. The fields :widths and :edges will also be filtered (mutated) if present, and any remaining fields will be copied unmodified.\n\nSee also: peakproms, findmaxima\n\n\n\nExamples\n\njulia> pks = findmaxima([0,5,2,3,3,1,4,0]);\n\njulia> pks = peakproms!(pks; min=2)\n(indices = [2, 7], heights = [5, 4], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[5, 3])\n\njulia> inds, proms = peakproms!(pks.indices, pks.data; max=4)\n([7], Union{Missing, Int64}[3])\n\n\n\n\n\npeakproms!(; [strict, min, max]) -> Function\n\nCreate a function, f(pks::NamedTuple), that calculates and filters (mutates) the peak prominences and other fields of its argument, pks, using any given keyword arguments.\n\nExamples\n\njulia> findmaxima([0,5,2,3,3,1,4,0]) |> peakproms!(; min=2)\n(indices = [2, 7], heights = [5, 4], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[5, 3])\n\n\n\n\n\n","category":"function"},{"location":"#Peaks.peakwidths","page":"Peaks.jl","title":"Peaks.peakwidths","text":"peakwidths(indices, x, proms; [strict=true, relheight=0.5, min, max]) -> (indices, widths, ledge, redge)\npeakwidths(pks::NamedTuple; [strict=true, relheight=0.5, min, max]) -> NamedTuple\n\nCalculate the widths of peak indices in x at a reference level based on proms and relheight, and removing peaks with widths less than min and/or greater than max. Returns the peaks, widths, and the left and right edges at the reference level.\n\nPeak width is the distance between the signal crossing a reference level before and after the peak. Signal crossings are linearly interpolated between indices. The reference level is the difference between the peak height and relheight times the peak prominence. Width cannot be calculated for a NaN or missing prominence.\n\nIf a NamedTuple pks is given, a new NamedTuple is returned with filtered copies of fields from pks. pks must have :indices, :heights, and :proms fields. If pks has :widths and :edges fields, they will not be recalculated, but filtered only. Any remaining fields will be copied unmodified.\n\nIf strict == true, the width for a peak with a gap in the signal (e.g. NaN, missing) at the reference level will match the value/type of the signal gap. Otherwise, the signal crossing will be linearly interpolated between the edges of the gap.\n\nSee also: peakwidths!, peakproms, findmaxima\n\nExamples\n\njulia> x = Float64[0,5,2,2,3,3,1,4,0];\n\njulia> pks = findmaxima(x) |> peakproms!(;max=2);\n\njulia> peakwidths(pks)\n(indices = [5], heights = [3.0], data = [0.0, 5.0, 2.0, 2.0, 3.0, 3.0, 1.0, 4.0, 0.0], proms = [1.0], widths = [1.75], edges = [(4.5, 6.25)])\n\njulia> x[4] = NaN;\n\njulia> peakwidths(pks.indices, x, pks.proms)\n([5], [NaN], [NaN], [6.25])\n\njulia> peakwidths(pks.indices, x, pks.proms; strict=false)\n([5], [2.25], [4.0], [6.25])\n\n\n\n\n\npeakwidths(; [strict, relheight, min, max]) -> Function\n\nCreate a function, f(pks::NamedTuple), that calculates and filters the peak widths of a copy of its argument, pks, using any given keyword arguments.\n\nExamples\n\njulia> findmaxima([0,5,2,3,3,1,4,0]) |> peakproms() |> peakwidths(; min=1.5)\n(indices = [4], heights = [3], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[1], widths = Union{Missing, Float64}[1.75], edges = Tuple{Union{Missing, Float64}, Union{Missing, Float64}}[(3.5, 5.25)])\n\n\n\n\n\n","category":"function"},{"location":"#Peaks.peakwidths!","page":"Peaks.jl","title":"Peaks.peakwidths!","text":"peakwidths!(indices, x; [strict=true, relheight=0.5, min, max]) -> (indices, widths, ledge, redge)\npeakwidths!(pks::NamedTuple; [strict=true, relheight=0.5, min, max]) -> NamedTuple\n\nCalculate the widths of peak indices in x at a reference level based on proms and relheight, removing peaks with widths less than min and/or greater than max. Returns the modified peaks, widths, and the left and right edges at the reference level.\n\nIf a NamedTuple pks is given, a new NamedTuple is returned with the same fields (references) from pks. pks must have :indices, :heights, and :proms fields. If pks has :widths and :edges fields, they will not be recalculated, but filtered only. Any remaining fields will be copied unmodified.\n\nSee also: peakwidths, peakproms, findmaxima\n\n\n\nExamples\n\njulia> x = Float64[0,5,2,2,3,3,1,4,0];\n\njulia> pks = findmaxima(x) |> peakproms!();\n\njulia> peakwidths!(pks; min=1)\n(indices = [2, 5], heights = [5.0, 3.0], data = [0.0, 5.0, 2.0, 2.0, 3.0, 3.0, 1.0, 4.0, 0.0], proms = [5.0, 1.0], widths = [1.333, 1.75], edges = [(1.5, 2.833), (4.5, 6.25)])\n\njulia> peakwidths!(pks.indices, pks.data, pks.proms; min=1)\n([2, 5], [1.333, 1.75], [1.5, 4.5], [2.833, 6.25])\n\n\n\n\n\npeakwidths!(; [strict, relheight, min, max]) -> Function\n\nCreate a function, f(pks::NamedTuple), that calculates and filters (mutates) the peak widths and other fields of its argument, pks, using any given keyword arguments.\n\nExamples\n\njulia> findmaxima([0,5,2,3,3,1,4,0]) |> peakproms!() |> peakwidths!(; min=1.5)\n(indices = [4], heights = [3], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[1], widths = Union{Missing, Float64}[1.75], edges = Tuple{Union{Missing, Float64}, Union{Missing, Float64}}[(3.5, 5.25)])\n\n\n\n\n\n","category":"function"},{"location":"#Peaks.peakheights","page":"Peaks.jl","title":"Peaks.peakheights","text":"peakheights(indices, heights; [min, max]) -> (indices, heights)\npeakheights(pks::NamedTuple; [min, max]) -> NamedTuple\n\nReturn a copy of indices and heights where peaks are removed if their height is less than min and/or greater than max.\n\nIf a NamedTuple pks is given, a new NamedTuple is returned with filtered copies of fields from pks. pks must have :indices and :heights fields. The fields :proms, :widths, and :edges will be filtered if present, and any remaining fields will be copied unmodified.\n\nSee also: peakproms, peakwidths, findmaxima\n\nExamples\n\njulia> x = [0,5,2,3,3,1,4,0];\n\njulia> pks = findmaxima(x)\n(indices = [2, 4, 7], heights = [5, 3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\njulia> peakheights(pks; max=4)\n(indices = [4, 7], heights = [3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\njulia> inds, heights = peakheights(pks.indices, pks.heights; max=4)\n([4, 7], [3, 4])\n\n\n\n\n\npeakheights(; [min, max]) -> Function\n\nCreate a function, f(pks::NamedTuple), that copies and filters the peak heights of its argument, pks, using any given keyword arguments.\n\nExamples\n\njulia> findmaxima([0, 5, 2, 3, 3, 1, 4, 0]) |> peakheights(; max=4)\n(indices = [4, 7], heights = [3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\n\n\n\n\n","category":"function"},{"location":"#Peaks.peakheights!","page":"Peaks.jl","title":"Peaks.peakheights!","text":"peakheights!(indices, heights; [min, max]) -> (indices, heights)\npeakheights!(pks::NamedTuple; [min, max]) -> NamedTuple\n\nFilter (mutate) and return indices and heights by removing peaks that are less than min and/or greater than max.\n\nIf a NamedTuple pks is given, a new NamedTuple is returned with the same fields (references) from pks. pks must have :indices and :heights fields. The fields :proms, :widths, and :edges will be filtered (mutated) if present, and any remaining fields will be referenced unmodified.\n\nSee also: peakproms, peakwidths, findmaxima filterpeaks!\n\nExamples\n\njulia> x = [0,5,2,3,3,1,4,0];\n\njulia> pks = findmaxima(x)\n(indices = [2, 4, 7], heights = [5, 3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\njulia> peakheights!(pks; max=4)\n(indices = [4, 7], heights = [3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\njulia> inds, heights = peakheights!(pks.indices, pks.heights; min=3.5)\n([7], [4])\n\n\n\n\n\npeakheights!(; [min, max]) -> Function\n\nCreate a function, f(pks::NamedTuple), that calculates peak heights and then filters (mutates) the fields of its argument, pks, using any given keyword arguments.\n\nExamples\n\njulia> findmaxima([0, 5, 2, 3, 3, 1, 4, 0]) |> peakheights!(; max=4)\n(indices = [4, 7], heights = [3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\n\n\n\n\n","category":"function"},{"location":"#Peaks.filterpeaks!","page":"Peaks.jl","title":"Peaks.filterpeaks!","text":"filterpeaks!(pks::NT, feature; [min, max]) where {NT<:NamedTuple} -> pks::NT\nfilterpeaks!(pks::NT, mask) -> pks::NT\n\nFilter the standard pks fields where peaks are removed if pks.$feature is less than min and/or greater than max. If a mask is given, a given peak i is filtered (removed) if mask[i] is false.\n\nStandard Peaks.jl fields of pks are :indices, :proms, :heights, :widths, :edges.\n\nExamples\n\njulia> pks = findmaxima([0,5,2,3,3,1,4,0])\n(indices = [2, 4, 7], heights = [5, 3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\njulia> filterpeaks!(pks, :heights; max=4)\n(indices = [4, 7], heights = [3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\njulia> pks = findmaxima([0,5,2,3,3,1,4,0]) |> peakproms!();\n\njulia> mask = [pks.heights[i] < 5 &&  pks.proms[i] > 2 for i in eachindex(pks.indices)]\n3-element Vector{Bool}:\n 0\n 0\n 1\n\njulia> filterpeaks!(pks, mask)\n(indices = [7], heights = [4], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[3])\n\n\n\n\n\nfilterpeaks!(pred, pks) -> NamedTuple\n\nApply a predicate function pred to NamedTuple slices (the scalar values related to each peak, e.g. (indices=5, heights=3, proms=2))to get a filter-mask . A peak is removed if pred returns false.\n\nExamples\n\njulia> pks = findmaxima([0,5,2,3,3,1,4,0])\n(indices = [2, 4, 7], heights = [5, 3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\njulia> filterpeaks!(pks) do nt\n           return nt.heights ≥ 5 || nt.heights ≤ 3\n       end\n(indices = [2, 4], heights = [5, 3], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\n\n\n\n\n","category":"function"},{"location":"#Peaks.findnextmaxima","page":"Peaks.jl","title":"Peaks.findnextmaxima","text":"findnextmaxima(x, i[, w=1; strict=true]) -> Int\n\nFind the index of the next maxima in x after or including i, where the maxima i is either the maximum of x[i-w:i+w] or the first index of a plateau. Returns lastindex(x) + 1 if no maxima occur after i.\n\nA plateau is defined as a maxima with consecutive equal (===/egal) maximal values which are bounded by lesser values immediately before and after the consecutive maximal values.\n\nWhen strict == true, no elements in x[i-w:i+w] may be missing or NaN, and the bounds of a plateau must exist. For strict == false, a maxima is the maximum of all non-NaN or missing elements in x[i-w:i+w], and plateau bounds are assumed to exist (i.e. missing, NaN, or either end of the array, x[begin-1] or x[end+1], may be treated as the bounds of a plateau).\n\nSee also: argmaxima\n\nExamples\n\njulia> findnextmaxima([0,2,0,1,1,0], 2)\n2\n\njulia> findnextmaxima([0,2,0,1,1,0], 3)\n4\n\n\n\n\n\n\n","category":"function"},{"location":"#Peaks.findnextminima","page":"Peaks.jl","title":"Peaks.findnextminima","text":"findnextminima(x, i[, w=1, strict=true]) -> Int\n\nFind the index of the next minima in x, after or including i, where the minima i is either the minimum of x[i-w:i+w] or the first index of a plateau. Returns lastindex(x) + 1 if no minima occur after i.\n\nA plateau is defined as a minima with consecutive equal (===/egal) minimal values which are bounded by greater values immediately before and after the consecutive minimal values.\n\nWhen strict == true, no elements in x[i-w:i+w] may be missing or NaN, and the bounds of a plateau must exist. For strict == false, a minima is the minimum of all non-NaN or missing elements in x[i-w:i+w], and plateau bounds are assumed to exist (i.e. missing, NaN, or either end of the array, x[begin-1] or x[end+1], may be treated as the bounds of a plateau).\n\nSee also: argminima\n\nExamples\n\njulia> findnextminima([3,2,3,1,1,3], 2)\n2\n\njulia> findnextminima([3,2,3,1,1,3], 3)\n4\n\n\n\n\n\n\n","category":"function"},{"location":"#Peaks.ismaxima","page":"Peaks.jl","title":"Peaks.ismaxima","text":"ismaxima(i, x[, w=1; strict=true]) -> Bool\n\nTest if i is a maxima in x, where the maxima i is either the maximum of x[i-w:i+w] or the first index of a plateau.\n\nA plateau is defined as a maxima with consecutive equal (===/egal) maximal values which are bounded by lesser values immediately before and after the consecutive maximal values.\n\nSee also: findnextmaxima\n\n\n\n\n\n","category":"function"},{"location":"#Peaks.isminima","page":"Peaks.jl","title":"Peaks.isminima","text":"isminima(i, x[, w=1; strict=true]) -> Bool\n\nTest if i is a minima in x, where the minima i is either the minimum of x[i-w:i+w] or the first index of a plateau.\n\nA plateau is defined as a minima with consecutive equal (===/egal) minimal values which are bounded by greater values immediately before and after the consecutive minimal values.\n\nSee also: findnextminima\n\n\n\n\n\n","category":"function"}]
}
