<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Peaks</title><meta name="title" content="API · Peaks"/><meta property="og:title" content="API · Peaks"/><meta property="twitter:title" content="API · Peaks"/><meta name="description" content="Documentation for Peaks."/><meta property="og:description" content="Documentation for Peaks."/><meta property="twitter:description" content="Documentation for Peaks."/><meta property="og:url" content="https://halleysfifthinc.github.io/Peaks.jl/reference/"/><meta property="twitter:url" content="https://halleysfifthinc.github.io/Peaks.jl/reference/"/><link rel="canonical" href="https://halleysfifthinc.github.io/Peaks.jl/reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Peaks</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../how-to/">How-to</a></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../glossary/">Glossary</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Finding-peaks"><span>Finding peaks</span></a></li><li><a class="tocitem" href="#Peak-characteristics-and-filtering"><span>Peak characteristics &amp; filtering</span></a></li><li><a class="tocitem" href="#Convenience-functions"><span>Convenience functions</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/halleysfifthinc/Peaks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/halleysfifthinc/Peaks.jl/blob/master/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Finding-peaks"><a class="docs-heading-anchor" href="#Finding-peaks">Finding peaks</a><a id="Finding-peaks-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-peaks" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.argmaxima" href="#Peaks.argmaxima"><code>Peaks.argmaxima</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">argmaxima(x[, w=1; strict=true]) -&gt; Vector{Int}</code></pre><p>Find the indices of local maxima in <code>x</code>, where each maxima <code>i</code> is either the maximum of <code>x[i-w:i+w]</code> or the first index of a plateau.</p><p>A plateau is defined as a maxima with consecutive equal (<code>==</code>) maximal values which are bounded by lesser values immediately before and after the consecutive maximal values.</p><p>When <code>strict == true</code>, no elements in <code>x[i-w:i+w]</code> may be <code>missing</code> or <code>NaN</code>, and the bounds of a plateau must exist. For <code>strict == false</code>, a maxima is the maximum of all non-<code>NaN</code> or <code>missing</code> elements in <code>x[i-w:i+w]</code>, and plateau bounds are assumed to exist (i.e. <code>missing</code>, <code>NaN</code>, or either end of the array, <code>x[begin-1]</code> or <code>x[end+1]</code>, may be treated as the bounds of a plateau).</p><p>See also: <a href="#Peaks.findmaxima"><code>findmaxima</code></a>, <a href="#Peaks.findnextmaxima"><code>findnextmaxima</code></a>, <a href="#Peaks.argminima"><code>argminima</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; argmaxima([0,2,0,1,1,0])
2-element Vector{Int64}:
 2
 4

julia&gt; argmaxima([2,0,1,1])
Int64[]

julia&gt; argmaxima([2,0,1,1]; strict=false)
2-element Vector{Int64}:
 1
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/minmax.jl#L131-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.argminima" href="#Peaks.argminima"><code>Peaks.argminima</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">argminima(x[, w=1; strict=false]) -&gt; Vector{Int}</code></pre><p>Find the indices of local minima in <code>x</code>, where each minima <code>i</code> is either the minimum of <code>x[i-w:i+w]</code> or the first index of a plateau.</p><p>A plateau is defined as a minima with consecutive equal (<code>==</code>) minimal values which are bounded by greater values immediately before and after the consecutive minimal values.</p><p>When <code>strict == true</code>, no elements in <code>x[i-w:i+w]</code> may be <code>missing</code> or <code>NaN</code>, and the bounds of a plateau must exist. For <code>strict == false</code>, a minima is the minimum of all non-<code>NaN</code> or <code>missing</code> elements in <code>x[i-w:i+w]</code>, and plateau bounds are assumed to exist (i.e. <code>missing</code>, <code>NaN</code>, or either end of the array, <code>x[begin-1]</code> or <code>x[end+1]</code>, may be treated as the bounds of a plateau).</p><p>See also: <a href="#Peaks.findminima"><code>findminima</code></a>, <a href="#Peaks.findnextminima"><code>findnextminima</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; argminima([3,2,3,1,1,3])
2-element Vector{Int64}:
 2
 4

julia&gt; argminima([2,3,1,1])
Int64[]

julia&gt; argminima([2,3,1,1]; strict=false)
2-element Vector{Int64}:
 1
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/minmax.jl#L325-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.maxima" href="#Peaks.maxima"><code>Peaks.maxima</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maxima(x[, w=1; strict=true]) -&gt; Vector{eltype(x)}</code></pre><p>Find the values of local maxima in <code>x</code>, where each maxima <code>i</code> is either the maximum of <code>x[i-w:i+w]</code> or the first index of a plateau.</p><p>A plateau is defined as a maxima with consecutive equal (<code>==</code>) maximal values which are bounded by lesser values immediately before and after the consecutive maximal values.</p><p>See also: <a href="#Peaks.argmaxima"><code>argmaxima</code></a>, <a href="#Peaks.findnextmaxima"><code>findnextmaxima</code></a>, <a href="#Peaks.minima"><code>minima</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/minmax.jl#L236-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.minima" href="#Peaks.minima"><code>Peaks.minima</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minima(x[, w=1; strict=true]) -&gt; Vector{eltype(x)}</code></pre><p>Find the values of local minima in <code>x</code>, where each minima <code>i</code> is either the minimum of <code>x[i-w:i+w]</code> or the first index of a plateau.</p><p>A plateau is defined as a minima with consecutive equal (<code>==</code>) minimal values which are bounded by greater values immediately before and after the consecutive minimal values.</p><p>See also: <a href="#Peaks.argminima"><code>argminima</code></a>, <a href="#Peaks.findnextminima"><code>findnextminima</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/minmax.jl#L431-L441">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.findmaxima" href="#Peaks.findmaxima"><code>Peaks.findmaxima</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findmaxima(x[, w=1; strict=true]) -&gt; (;indices, heights, data)</code></pre><p>Find the indices and values of local maxima in <code>x</code>, where each maxima <code>i</code> is either the maximum of <code>x[i-w:i+w]</code> or the first index of a plateau.</p><p>Returns a <code>NamedTuple</code> contains the fields <code>indices</code>, <code>heights</code>, <code>data</code>, which are equivalent to <code>heights = data[indices]</code>. The <code>data</code> field is a reference (not a copy) to the argument <code>x</code>.</p><p>A plateau is defined as a maxima with consecutive equal (<code>==</code>) maximal values which are bounded by lesser values immediately before and after the consecutive maximal values.</p><p>See also: <a href="#Peaks.argmaxima"><code>argmaxima</code></a>, <a href="#Peaks.findnextmaxima"><code>findnextmaxima</code></a>, <a href="#Peaks.findminima"><code>findminima</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = [1, 5, 1, 3, 2];

julia&gt; pks = findmaxima(data)
(indices = [2, 4], heights = [5, 3], data = [1, 5, 1, 3, 2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/minmax.jl#L254-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.findminima" href="#Peaks.findminima"><code>Peaks.findminima</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findminima(x[, w=1; strict=true]) -&gt; (;indices, heights, data)</code></pre><p>Find the indices and values of local minima in <code>x</code>, where each minima <code>i</code> is either the minimum of <code>x[i-w:i+w]</code> or the first index of a plateau.</p><p>Returns a <code>NamedTuple</code> contains the fields <code>indices</code>, <code>heights</code>, <code>data</code>, which are equivalent to <code>heights = data[indices]</code>. The <code>data</code> field is a reference (not a copy) to the argument <code>x</code>.</p><p>A plateau is defined as a minima with consecutive equal (<code>==</code>) minimal values which are bounded by greater values immediately before and after the consecutive minimal values.</p><p>See also: <a href="#Peaks.argminima"><code>argminima</code></a>, <a href="#Peaks.findnextminima"><code>findnextminima</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = [1, 5, 1, 3, 2];

julia&gt; valleys = findminima(data)
(indices = [3], heights = [1], data = [1, 5, 1, 3, 2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/minmax.jl#L449-L471">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.simplemaxima" href="#Peaks.simplemaxima"><code>Peaks.simplemaxima</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simplemaxima(x) -&gt; Vector{Int}</code></pre><p>Find the indices of local maxima in <code>x</code>, where each maxima <code>i</code> is greater than both adjacent elements or is the first index of a plateau.</p><p>A plateau is defined as a maxima with consecutive equal (<code>==</code>) maximal values which are bounded by lesser values immediately before and after the plateau.</p><p>This function is semantically equivalent to <code>argmaxima(x, w=1; strict=true)</code>, but is faster because of its simplified set of features. (The difference in speed scales with <code>length(x)</code>; for input arrays longer than 5k elements, <code>argmaxima</code> is roughly 7x slower.)</p><p>Vectors with <code>missing</code>s are not supported by <code>simplemaxima</code>, use <code>argmaxima</code> if this is needed.</p><p>See also: <a href="#Peaks.argmaxima"><code>argmaxima</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; simplemaxima([0,2,0,1,1,0])
2-element Vector{Int64}:
 2
 4

julia&gt; argmaxima([0,2,0,1,1,0])
2-element Vector{Int64}:
 2
 4

julia&gt; simplemaxima([2,0,1,1])
Int64[]

julia&gt; @btime simplemaxima(x) setup=(x = repeat([0,1]; outer=100));
  269.865 ns (3 allocations: 1.00 KiB)

julia&gt; @btime argmaxima(x) setup=(x = repeat([0,1]; outer=100));
  748.780 ns (3 allocations: 1.00 KiB)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/minmax.jl#L194-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.simpleminima" href="#Peaks.simpleminima"><code>Peaks.simpleminima</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simpleminima(x) -&gt; Vector{Int}</code></pre><p>Find the indices of local minima in <code>x</code>, where each minima <code>i</code> is less than both adjacent elements or is the first index of a plateau.</p><p>A plateau is defined as a minima with consecutive equal (<code>==</code>) minimal values which are bounded by greater values immediately before and after the plateau.</p><p>This function is semantically equivalent to <code>argminima(x, w=1; strict=true)</code>, but is faster because of its simplified set of features. (The difference in speed scales with <code>length(x)</code>; for input arrays longer than 5k elements, <code>argmaxima</code> is roughly 7x slower.)</p><p>Vectors with <code>missing</code>s are not supported by <code>simpleminima</code>, use <code>argminima</code> if this is needed.</p><p>See also: <a href="#Peaks.argminima"><code>argminima</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; simpleminima([3,2,3,1,1,3])
2-element Vector{Int64}:
 2
 4

julia&gt; argminima([3,2,3,1,1,3])
2-element Vector{Int64}:
 2
 4

julia&gt; simpleminima([2,3,1,1])
Int64[]

julia&gt; @btime simpleminima(x) setup=(x = repeat([0,1]; outer=100));
  280.362 ns (3 allocations: 1.00 KiB)

julia&gt; @btime argminima(x) setup=(x = repeat([0,1]; outer=100));
  823.634 ns (3 allocations: 1.00 KiB)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/minmax.jl#L389-L428">source</a></section></article><h2 id="Peak-characteristics-and-filtering"><a class="docs-heading-anchor" href="#Peak-characteristics-and-filtering">Peak characteristics &amp; filtering</a><a id="Peak-characteristics-and-filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Peak-characteristics-and-filtering" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.peakproms" href="#Peaks.peakproms"><code>Peaks.peakproms</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">peakproms(indices, x; [strict=true, min, max]) -&gt; (indices, proms)
peakproms(pks::NamedTuple; [strict=true, min, max]) -&gt; NamedTuple</code></pre><p>Calculate the prominences of peak <code>indices</code> in <code>x</code>, and remove peaks with prominences less than <code>min</code> and/or greater than <code>max</code>.</p><p>Peak prominence is the absolute height (value) difference between the current peak and the larger of the two adjacent smallest magnitude points between the current peak and adjacent larger peaks or signal ends.</p><p>If a NamedTuple <code>pks</code> is given, a new NamedTuple is returned with filtered copies of fields from <code>pks</code>. <code>pks</code> must have <code>:indices</code> and <code>:heights</code> fields. If <code>pks</code> has a <code>:proms</code> field, prominences will only be filtered, and not be recalculated. The fields <code>:widths</code> and <code>:edges</code> will also be filtered if present, and any remaining fields will be copied unmodified.</p><p>If <code>strict == true</code>, the prominence for a peak with a <code>NaN</code> or <code>missing</code> between the current peak and either adjacent larger peaks will be <code>NaN</code> or <code>missing</code>, otherwise, it will be the larger of the smallest non-<code>NaN</code> or <code>missing</code> values between the current peak and adjacent larger peaks for <code>strict == false</code>.</p><p>See also: <a href="#Peaks.peakproms!"><code>peakproms!</code></a>, <a href="#Peaks.findmaxima"><code>findmaxima</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pks = findmaxima([0,5,2,3,3,1,4,0]);

julia&gt; pks = peakproms(pks; min=2)
(indices = [2, 7], heights = [5, 4], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[5, 3])

julia&gt; inds, proms = peakproms(pks.indices, pks.data; max=4)
([7], Union{Missing, Int64}[3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/peakprom.jl#L1-L35">source</a></section><section><div><pre><code class="language-julia hljs">peakproms(; [strict, min, max]) -&gt; Function</code></pre><p>Create a function, <code>f(pks::NamedTuple)</code>, that calculates and filters the peak prominences of a copy of its argument, <code>pks</code>, using any given keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findmaxima([0,5,2,3,3,1,4,0]) |&gt; peakproms(; min=2)
(indices = [2, 7], heights = [5, 4], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[5, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/peakprom.jl#L57-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.peakproms!" href="#Peaks.peakproms!"><code>Peaks.peakproms!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">peakproms!(indices, x; [strict=true, min, max]) -&gt; (indices, proms)
peakproms!(pks::NamedTuple; [strict=true, min, max]) -&gt; NamedTuple</code></pre><p>Calculate the prominences of peak <code>indices</code> in <code>x</code>, and remove peaks with prominences less than <code>min</code> and/or greater than <code>max</code>.</p><p>If a NamedTuple <code>pks</code> is given, a new NamedTuple is returned with the same fields (references) from <code>pks</code>. <code>pks</code> must have <code>:indices</code> and <code>:heights</code> fields. If <code>pks</code> has a <code>:proms</code> field, prominences will only be filtered, and not be recalculated. The fields <code>:widths</code> and <code>:edges</code> will also be filtered (mutated) if present, and any remaining fields will be copied unmodified.</p><p>See also: <a href="#Peaks.peakproms"><code>peakproms</code></a>, <a href="#Peaks.findmaxima"><code>findmaxima</code></a></p><p><strong></strong></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pks = findmaxima([0,5,2,3,3,1,4,0]);

julia&gt; pks = peakproms!(pks; min=2)
(indices = [2, 7], heights = [5, 4], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[5, 3])

julia&gt; inds, proms = peakproms!(pks.indices, pks.data; max=4)
([7], Union{Missing, Int64}[3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/peakprom.jl#L102-L127">source</a></section><section><div><pre><code class="language-julia hljs">peakproms!(; [strict, min, max]) -&gt; Function</code></pre><p>Create a function, <code>f(pks::NamedTuple)</code>, that calculates and filters (mutates) the peak prominences and other fields of its argument, <code>pks</code>, using any given keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findmaxima([0,5,2,3,3,1,4,0]) |&gt; peakproms!(; min=2)
(indices = [2, 7], heights = [5, 4], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[5, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/peakprom.jl#L256-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.peakwidths" href="#Peaks.peakwidths"><code>Peaks.peakwidths</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">peakwidths(indices, x, proms; [strict=true, relheight=0.5, min, max]) -&gt; (indices, widths, ledge, redge)
peakwidths(pks::NamedTuple; [strict=true, relheight=0.5, min, max]) -&gt; NamedTuple</code></pre><p>Calculate the widths of peak <code>indices</code> in <code>x</code> at a reference level based on <code>proms</code> and <code>relheight</code>, and removing peaks with widths less than <code>min</code> and/or greater than <code>max</code>. Returns the peaks, widths, and the left and right edges at the reference level.</p><p>Peak width is the distance between the signal crossing a reference level before and after the peak. Signal crossings are linearly interpolated between indices. The reference level is the difference between the peak height and <code>relheight</code> times the peak prominence. Width cannot be calculated for a <code>NaN</code> or <code>missing</code> prominence.</p><p>If a NamedTuple <code>pks</code> is given, a new NamedTuple is returned with filtered copies of fields from <code>pks</code>. <code>pks</code> must have <code>:indices</code>, <code>:heights</code>, and <code>:proms</code> fields. If <code>pks</code> has <code>:widths</code> and <code>:edges</code> fields, they will not be recalculated, but filtered only. Any remaining fields will be copied unmodified.</p><p>If <code>strict == true</code>, the width for a peak with a gap in the signal (e.g. <code>NaN</code>, <code>missing</code>) at the reference level will match the gap (e.g. <code>NaN</code> for <code>NaN</code>, etc.). Otherwise, the signal crossing will be linearly interpolated between the edges of the gap.</p><p>See also: <a href="#Peaks.peakwidths!"><code>peakwidths!</code></a>, <a href="#Peaks.peakproms"><code>peakproms</code></a>, <a href="#Peaks.findmaxima"><code>findmaxima</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Float64[0,5,2,2,3,3,1,4,0];

julia&gt; pks = findmaxima(x) |&gt; peakproms!(;max=2);

julia&gt; peakwidths(pks)
(indices = [5], heights = [3.0], data = [0.0, 5.0, 2.0, 2.0, 3.0, 3.0, 1.0, 4.0, 0.0], proms = [1.0], widths = [1.75], edges = [(4.5, 6.25)])

julia&gt; x[4] = NaN;

julia&gt; peakwidths(pks.indices, x, pks.proms)
([5], [NaN], [NaN], [6.25])

julia&gt; peakwidths(pks.indices, x, pks.proms; strict=false)
([5], [2.25], [4.0], [6.25])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/peakwidth.jl#L1-L42">source</a></section><section><div><pre><code class="language-julia hljs">peakwidths(; [strict, relheight, min, max]) -&gt; Function</code></pre><p>Create a function, <code>f(pks::NamedTuple)</code>, that calculates and filters the peak widths of a copy of its argument, <code>pks</code>, using any given keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findmaxima([0,5,2,3,3,1,4,0]) |&gt; peakproms() |&gt; peakwidths(; min=1.5)
(indices = [4], heights = [3], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[1], widths = Union{Missing, Float64}[1.75], edges = Tuple{Union{Missing, Float64}, Union{Missing, Float64}}[(3.5, 5.25)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/peakwidth.jl#L66-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.peakwidths!" href="#Peaks.peakwidths!"><code>Peaks.peakwidths!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">peakwidths!(indices, x; [strict=true, relheight=0.5, min, max]) -&gt; (indices, widths, ledge, redge)
peakwidths!(pks::NamedTuple; [strict=true, relheight=0.5, min, max]) -&gt; NamedTuple</code></pre><p>Calculate the widths of peak <code>indices</code> in <code>x</code> at a reference level based on <code>proms</code> and <code>relheight</code>, removing peaks with widths less than <code>min</code> and/or greater than <code>max</code>. Returns the modified peaks, widths, and the left and right edges at the reference level.</p><p>If a NamedTuple <code>pks</code> is given, a new NamedTuple is returned with the same fields (references) from <code>pks</code>. <code>pks</code> must have <code>:indices</code>, <code>:heights</code>, and <code>:proms</code> fields. If <code>pks</code> has <code>:widths</code> and <code>:edges</code> fields, they will not be recalculated, but filtered only. Any remaining fields will be copied unmodified.</p><p>See also: <a href="#Peaks.peakwidths"><code>peakwidths</code></a>, <a href="#Peaks.peakproms"><code>peakproms</code></a>, <a href="#Peaks.findmaxima"><code>findmaxima</code></a></p><p><strong></strong></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Float64[0,5,2,2,3,3,1,4,0];

julia&gt; pks = findmaxima(x) |&gt; peakproms!();

julia&gt; peakwidths!(pks; min=1)
(indices = [2, 5], heights = [5.0, 3.0], data = [0.0, 5.0, 2.0, 2.0, 3.0, 3.0, 1.0, 4.0, 0.0], proms = [5.0, 1.0], widths = [1.333, 1.75], edges = [(1.5, 2.833), (4.5, 6.25)])

julia&gt; peakwidths!(pks.indices, pks.data, pks.proms; min=1)
([2, 5], [1.333, 1.75], [1.5, 4.5], [2.833, 6.25])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/peakwidth.jl#L116-L143">source</a></section><section><div><pre><code class="language-julia hljs">peakwidths!(; [strict, relheight, min, max]) -&gt; Function</code></pre><p>Create a function, <code>f(pks::NamedTuple)</code>, that calculates and filters (mutates) the peak widths and other fields of its argument, <code>pks</code>, using any given keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findmaxima([0,5,2,3,3,1,4,0]) |&gt; peakproms!() |&gt; peakwidths!(; min=1.5)
(indices = [4], heights = [3], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[1], widths = Union{Missing, Float64}[1.75], edges = Tuple{Union{Missing, Float64}, Union{Missing, Float64}}[(3.5, 5.25)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/peakwidth.jl#L223-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.peakheights" href="#Peaks.peakheights"><code>Peaks.peakheights</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">peakheights(indices, heights; [min, max]) -&gt; (indices, heights)
peakheights(pks::NamedTuple; [min, max]) -&gt; NamedTuple</code></pre><p>Return a copy of <code>indices</code> and <code>heights</code> where peaks are removed if their height is less than <code>min</code> and/or greater than <code>max</code>.</p><p>If a NamedTuple <code>pks</code> is given, a new NamedTuple is returned with filtered copies of fields from <code>pks</code>. <code>pks</code> must have <code>:indices</code> and <code>:heights</code> fields. The fields <code>:proms</code>, <code>:widths</code>, and <code>:edges</code> will be filtered if present, and any remaining fields will be copied unmodified.</p><p>See also: <a href="#Peaks.peakproms"><code>peakproms</code></a>, <a href="#Peaks.peakwidths"><code>peakwidths</code></a>, <a href="#Peaks.findmaxima"><code>findmaxima</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [0,5,2,3,3,1,4,0];

julia&gt; pks = findmaxima(x)
(indices = [2, 4, 7], heights = [5, 3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])

julia&gt; peakheights(pks; max=4)
(indices = [4, 7], heights = [3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])

julia&gt; inds, heights = peakheights(pks.indices, pks.heights; max=4)
([4, 7], [3, 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/peakheight.jl#L1-L29">source</a></section><section><div><pre><code class="language-julia hljs">peakheights(; [min, max]) -&gt; Function</code></pre><p>Create a function, <code>f(pks::NamedTuple)</code>, that copies and filters the peak heights of its argument, <code>pks</code>, using any given keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findmaxima([0, 5, 2, 3, 3, 1, 4, 0]) |&gt; peakheights(; max=4)
(indices = [4, 7], heights = [3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/peakheight.jl#L46-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.peakheights!" href="#Peaks.peakheights!"><code>Peaks.peakheights!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">peakheights!(indices, heights; [min, max]) -&gt; (indices, heights)
peakheights!(pks::NamedTuple; [min, max]) -&gt; NamedTuple</code></pre><p>Filter (mutate) and return <code>indices</code> and <code>heights</code> by removing peaks that are less than <code>min</code> and/or greater than <code>max</code>.</p><p>If a NamedTuple <code>pks</code> is given, a new NamedTuple is returned with the same fields (references) from <code>pks</code>. <code>pks</code> must have <code>:indices</code> and <code>:heights</code> fields. The fields <code>:proms</code>, <code>:widths</code>, and <code>:edges</code> will be filtered (mutated) if present, and any remaining fields will be referenced unmodified.</p><p>See also: <a href="#Peaks.peakproms"><code>peakproms</code></a>, <a href="#Peaks.peakwidths"><code>peakwidths</code></a>, <a href="#Peaks.findmaxima"><code>findmaxima</code></a> <a href="#Peaks.filterpeaks!"><code>filterpeaks!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [0,5,2,3,3,1,4,0];

julia&gt; pks = findmaxima(x)
(indices = [2, 4, 7], heights = [5, 3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])

julia&gt; peakheights!(pks; max=4)
(indices = [4, 7], heights = [3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])

julia&gt; inds, heights = peakheights!(pks.indices, pks.heights; min=3.5)
([7], [4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/peakheight.jl#L62-L90">source</a></section><section><div><pre><code class="language-julia hljs">peakheights!(; [min, max]) -&gt; Function</code></pre><p>Create a function, <code>f(pks::NamedTuple)</code>, that calculates peak heights and then filters (mutates) the fields of its argument, <code>pks</code>, using any given keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findmaxima([0, 5, 2, 3, 3, 1, 4, 0]) |&gt; peakheights!(; max=4)
(indices = [4, 7], heights = [3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/peakheight.jl#L119-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.filterpeaks!" href="#Peaks.filterpeaks!"><code>Peaks.filterpeaks!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filterpeaks!(pks::NT, feature; [min, max]) where {NT&lt;:NamedTuple} -&gt; pks::NT
filterpeaks!(pks::NT, mask) -&gt; pks::NT</code></pre><p>Filter the standard <code>pks</code> fields where peaks are removed if <code>pks.$feature</code> is less than <code>min</code> and/or greater than <code>max</code>. If a <code>mask</code> is given, a given peak <code>i</code> is filtered (removed) if <code>mask[i]</code> is <code>false</code>.</p><p>Standard Peaks.jl fields of <code>pks</code> are <code>:indices</code>, <code>:proms</code>, <code>:heights</code>, <code>:widths</code>, <code>:edges</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pks = findmaxima([0,5,2,3,3,1,4,0])
(indices = [2, 4, 7], heights = [5, 3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])

julia&gt; filterpeaks!(pks, :heights; max=4)
(indices = [4, 7], heights = [3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])

julia&gt; pks = findmaxima([0,5,2,3,3,1,4,0]) |&gt; peakproms!();

julia&gt; mask = [pks.heights[i] &lt; 5 &amp;&amp;  pks.proms[i] &gt; 2 for i in eachindex(pks.indices)]
3-element Vector{Bool}:
 0
 0
 1

julia&gt; filterpeaks!(pks, mask)
(indices = [7], heights = [4], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/utils.jl#L21-L49">source</a></section><section><div><pre><code class="language-julia hljs">filterpeaks!(pred, pks) -&gt; NamedTuple</code></pre><p>Apply a predicate function <code>pred</code> to NamedTuple slices (the scalar values related to each peak, e.g. <code>(indices=5, heights=3, proms=2)</code>) to and remove a peak if <code>pred</code> returns <code>false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pks = findmaxima([0,5,2,3,3,1,4,0])
(indices = [2, 4, 7], heights = [5, 3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])

julia&gt; filterpeaks!(pks) do nt
           return nt.heights ≥ 5 || nt.heights ≤ 3
       end
(indices = [2, 4], heights = [5, 3], data = [0, 5, 2, 3, 3, 1, 4, 0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/utils.jl#L87-L104">source</a></section></article><h2 id="Convenience-functions"><a class="docs-heading-anchor" href="#Convenience-functions">Convenience functions</a><a id="Convenience-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.findnextmaxima" href="#Peaks.findnextmaxima"><code>Peaks.findnextmaxima</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findnextmaxima(x, i[, w=1; strict=true]) -&gt; Int</code></pre><p>Find the index of the next maxima in <code>x</code> after or including <code>i</code>, where the maxima <code>i</code> is either the maximum of <code>x[i-w:i+w]</code> or the first index of a plateau. Returns <code>lastindex(x) + 1</code> if no maxima occur after <code>i</code>.</p><p>A plateau is defined as a maxima with consecutive equal (<code>==</code>) maximal values which are bounded by lesser values immediately before and after the consecutive maximal values.</p><p>When <code>strict == true</code>, no elements in <code>x[i-w:i+w]</code> may be <code>missing</code> or <code>NaN</code>, and the bounds of a plateau must exist. For <code>strict == false</code>, a maxima is the maximum of all non-<code>NaN</code> or <code>missing</code> elements in <code>x[i-w:i+w]</code>, and plateau bounds are assumed to exist (i.e. <code>missing</code>, <code>NaN</code>, or either end of the array, <code>x[begin-1]</code> or <code>x[end+1]</code>, may be treated as the bounds of a plateau).</p><p>See also: <a href="#Peaks.argmaxima"><code>argmaxima</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findnextmaxima([0,2,0,1,1,0], 2)
2

julia&gt; findnextmaxima([0,2,0,1,1,0], 3)
4
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/minmax.jl#L88-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.findnextminima" href="#Peaks.findnextminima"><code>Peaks.findnextminima</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findnextminima(x, i[, w=1, strict=true]) -&gt; Int</code></pre><p>Find the index of the next minima in <code>x</code>, after or including <code>i</code>, where the minima <code>i</code> is either the minimum of <code>x[i-w:i+w]</code> or the first index of a plateau. Returns <code>lastindex(x) + 1</code> if no minima occur after <code>i</code>.</p><p>A plateau is defined as a minima with consecutive equal (<code>==</code>) minimal values which are bounded by greater values immediately before and after the consecutive minimal values.</p><p>When <code>strict == true</code>, no elements in <code>x[i-w:i+w]</code> may be <code>missing</code> or <code>NaN</code>, and the bounds of a plateau must exist. For <code>strict == false</code>, a minima is the minimum of all non-<code>NaN</code> or <code>missing</code> elements in <code>x[i-w:i+w]</code>, and plateau bounds are assumed to exist (i.e. <code>missing</code>, <code>NaN</code>, or either end of the array, <code>x[begin-1]</code> or <code>x[end+1]</code>, may be treated as the bounds of a plateau).</p><p>See also: <a href="#Peaks.argminima"><code>argminima</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findnextminima([3,2,3,1,1,3], 2)
2

julia&gt; findnextminima([3,2,3,1,1,3], 3)
4
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/minmax.jl#L282-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.ismaxima" href="#Peaks.ismaxima"><code>Peaks.ismaxima</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ismaxima(i, x[, w=1; strict=true]) -&gt; Bool</code></pre><p>Test if <code>i</code> is a maxima in <code>x</code>, where the maxima <code>i</code> is either the maximum of <code>x[i-w:i+w]</code> or the first index of a plateau.</p><p>A plateau is defined as a maxima with consecutive equal (<code>==</code>) maximal values which are bounded by lesser values immediately before and after the consecutive maximal values.</p><p>See also: <a href="#Peaks.findnextmaxima"><code>findnextmaxima</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/minmax.jl#L118-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.isminima" href="#Peaks.isminima"><code>Peaks.isminima</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isminima(i, x[, w=1; strict=true]) -&gt; Bool</code></pre><p>Test if <code>i</code> is a minima in <code>x</code>, where the minima <code>i</code> is either the minimum of <code>x[i-w:i+w]</code> or the first index of a plateau.</p><p>A plateau is defined as a minima with consecutive equal (<code>==</code>) minimal values which are bounded by greater values immediately before and after the consecutive minimal values.</p><p>See also: <a href="#Peaks.findnextminima"><code>findnextminima</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/minmax.jl#L312-L322">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Peaks.isplateau" href="#Peaks.isplateau"><code>Peaks.isplateau</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isplateau(i, x[, w=1; strict=true]) -&gt; Union{Missing,Bool}</code></pre><p>Test if <code>i</code> is a plateau in <code>x</code>, where a plateau is defined as a maxima or minima with consecutive equal (<code>==</code>) extreme values which are bounded by lesser values immediately before and after the consecutive values. Returns <code>false</code> if <code>i</code> is the last index in <code>x</code>.</p><p>See also: <a href="#Peaks.ismaxima"><code>ismaxima</code></a>, <a href="#Peaks.isminima"><code>isminima</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/halleysfifthinc/Peaks.jl/blob/77190d1639da9b693ee8bbbf44daa11d35152cde/src/minmax.jl#L477-L485">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../glossary/">« Glossary</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.6.0 on <span class="colophon-date" title="Friday 23 August 2024 04:41">Friday 23 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
