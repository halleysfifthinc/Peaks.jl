var documenterSearchIndex = {"docs":
[{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"include(\"plots/benchmark_plots.jl\")","category":"page"},{"location":"benchmarks/#Peak-finding-benchmarks","page":"Benchmarks","title":"Peak finding benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Peaks.jl functions can be very fast, but some features (wider window widths, support for missing, etc) come at a performance penalty. Below, 3 example peak finding functions[1] and Images.findlocalmaxima are benchmarked against argmaxima and simplemaxima from Peaks.jl. (Only maxima type functions are benchmarked below, but similar results can be found for equivalent minima finding functions.)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[1]: Currently/previously used by other Julia packages or public code. Those packages/codes are intentionally not named because they are not primarily peak finding packages, and the functions aren't part of their public API.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"One important difference between the Peaks.jl functions (argmaxima, simplemaxima, etc) and Images.findlocalmaxima or the example functions is that only Peaks.jl functions recognize plateaus. Depending on the type and origins of your data (quantized data, such as data sampled from physical measurements using ADC's, has a higher likelihood of plateaus), recognizing plateaus may or may not be an important/relevant feature. As a result, Peaks.jl functions are doing more work, but are still competitive with other obvious implementations.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"times_plot # hide","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The data generation for the above benchmark was a sine function with a peak every 5 elements; similar results are observed for more sparsely spaced peaks. However, that benchmark may not accurately reflect real-world performance when peaks are spaced more variably[2].","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[2]: This benchmark will be distorted by how well the CPU branch-predictor can learn each function; more predictable branches will make the function run faster than could be expected with more realistic data.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"When benchmarking against randomly sampled data, we see roughly the same performance characteristics, now presented relative to the speed of simplemaxima (higher is slower):","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"ratio_plot # hide","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The large difference in speed between simplemaxima and other functions is due to the use of SIMD code for suitable input arrays and element types; see the docstring for its limitations compared to argmaxima.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Benchmarked functions:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"details: `naivemaxima`\nfunction naivemaxima(x)\n   pks = Int[]\n   i = firstindex(x) + 1\n   for i in firstindex(x)+1:lastindex(x)-1\n       if x[i+1] < x[i] > x[i-1]\n           push!(pks, i)\n       end\n   end\n   return pks\nend","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"details: `diffmaxima`\nfunction diffmaxima(x)\n    dx = diff(x)\n    return findall((diff(dx) .< 0) .& (dx[begin:end-1] .> 0) .& (dx[begin+1:end] .< 0)) .+ firstindex(x)\nend","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"details: `viewsmaxima`\nfunction viewsmaxima(x)\n    x1 = @view x[begin:end - 2]\n    x2 = @view x[begin+1:end - 1]\n    x3 = @view x[begin+2:end]\n    return axes(x,1)[2:end-1][x1 .< x2 .> x3]\nend","category":"page"},{"location":"how-to/","page":"How-to","title":"How-to","text":"using Peaks, Plots, DataFrames; gr()\n\nusing Random\nRandom.seed!(0xFEED)","category":"page"},{"location":"how-to/","page":"How-to","title":"How-to","text":"Signals often contain peaks that you aren't interested in. This guide will show you how to filter peaks you don't want.","category":"page"},{"location":"how-to/#How-to-filter-peaks-by-peak-spacing","page":"How-to","title":"How to filter peaks by peak spacing","text":"","category":"section"},{"location":"how-to/","page":"How-to","title":"How-to","text":"Real data typically has noise that can create lots of closely spaced, unwanted peaks.","category":"page"},{"location":"how-to/","page":"How-to","title":"How-to","text":"T = 1/25\nt = 0:T:23\n\nmultisin(t) = 3sinpi(0.1t) + 2sinpi(0.2t) + sinpi(0.6t)\n\ny = multisin.(t) .+ 0.1rand(length(t))\n\npks = findmaxima(y)\nplotpeaks(t, y; peaks=pks.indices)","category":"page"},{"location":"how-to/","page":"How-to","title":"How-to","text":"The simplest way to remove those peaks (assuming the signal is already filtered) is by setting the window w argument in findmaxima and friends:","category":"page"},{"location":"how-to/","page":"How-to","title":"How-to","text":"pks = findmaxima(y, 15)\nf = plotpeaks(t, y; peaks=pks.indices)","category":"page"},{"location":"how-to/","page":"How-to","title":"How-to","text":"If only the peaks circled in blue are wanted, then setting the window w too wide won't work, since there are larger peaks that would become dominant.","category":"page"},{"location":"how-to/","page":"How-to","title":"How-to","text":"pks = findmaxima(y, 15) # hide\nwpks = peakproms(pks; max=1) # hide\nf = plot(t[wpks.indices], wpks.heights; seriestype=:scatter, markershape=:circle, label=\"\", # hide\n    markersize=10, markercolor=RGBA(1,1,1,0), markerstrokealpha=.1, markerstrokecolor=:blue, # hide\n    markerstrokewidth=2, z_order=1) # hide\nplotpeaks!(f, t, y; peaks=pks.indices) # hide","category":"page"},{"location":"how-to/#How-to-filter-peaks-by-peak-characteristics","page":"How-to","title":"How to filter peaks by peak characteristics","text":"","category":"section"},{"location":"how-to/","page":"How-to","title":"How-to","text":"Every peak-characteristic finding function can optionally filter the newly calculated characteristics using the keyword arguments min and max.","category":"page"},{"location":"how-to/","page":"How-to","title":"How-to","text":"Plotting all the peak characteristics and/or looking at the characteristic values can help show which characteristics should be filtered to remove all the unwanted peaks.","category":"page"},{"location":"how-to/","page":"How-to","title":"How-to","text":"pks = findmaxima(y, 15) # hide\nwpks = peakproms(pks; max=1) # hide\nf = plot(t[wpks.indices], wpks.heights; seriestype=:scatter, markershape=:circle, label=\"\", # hide\n    markersize=10, markercolor=RGBA(1,1,1,0), markerstrokealpha=.1, markerstrokecolor=:blue, # hide\n    markerstrokewidth=2, z_order=1) # hide\nplotpeaks!(f, t, y; peaks=pks.indices, prominences=true, widths=true)","category":"page"},{"location":"how-to/","page":"How-to","title":"How-to","text":"pks = peakproms(pks) |> peakwidths # hide\nDataFrame(pks[Not(:data)])","category":"page"},{"location":"how-to/","page":"How-to","title":"How-to","text":"Looking at the figure and the characteristic values, we can list the usefulness of each characteristic for filtering:","category":"page"},{"location":"how-to/","page":"How-to","title":"How-to","text":"Peak height?\nThere are other peaks around the same height as the peaks we want, so applying a min or max height filter would remove peaks we want, or allow peaks we don't want.\nPeak prominence?\nAll the peaks we want have similarly small prominences (<1) and the other peaks have much larger prominences (>2). This would be a good filtering option, using peakproms(pks; max=1).\nPeak width?\nThe peaks we want have fairly similar widths (~15-25 elements wide), and the other peaks have larger widths (>40 elements wide). This would be a good filter, using peakwidths(pks; max=30).","category":"page"},{"location":"how-to/","page":"How-to","title":"How-to","text":"In this case, filtering by peak prominence would be the better choice, because calculating peak widths depends on prominences, so filtering by peak prominence would do the job while avoiding unnecessary work.","category":"page"},{"location":"how-to/","page":"How-to","title":"How-to","text":"In many cases, the desired peaks aren't very different from many other peaks in any one peak characteristic. In these situations, it may be necessary to filter multiple times based on different peak characteristics or different min/max thresholds. There is also a filterpeaks! function which allows you to give a filter predicate and filter by multiple characteristics at once.","category":"page"},{"location":"reference/#Finding-peaks","page":"API","title":"Finding peaks","text":"","category":"section"},{"location":"reference/","page":"API","title":"API","text":"argmaxima\nargminima\nmaxima\nminima\nfindmaxima\nfindminima\nsimplemaxima\nsimpleminima","category":"page"},{"location":"reference/#Peaks.argmaxima","page":"API","title":"Peaks.argmaxima","text":"argmaxima(x[, w=1; strict=true]) -> Vector{Int}\n\nFind the indices of local maxima in x, where each maxima i is either the maximum of x[i-w:i+w] or the first index of a plateau.\n\nA plateau is defined as a maxima with consecutive equal (==) maximal values which are bounded by lesser values immediately before and after the consecutive maximal values.\n\nWhen strict == true, no elements in x[i-w:i+w] may be missing or NaN, and the bounds of a plateau must exist. For strict == false, a maxima is the maximum of all non-NaN or missing elements in x[i-w:i+w], and plateau bounds are assumed to exist (i.e. missing, NaN, or either end of the array, x[begin-1] or x[end+1], may be treated as the bounds of a plateau).\n\nSee also: findmaxima, findnextmaxima, argminima\n\nExamples\n\njulia> argmaxima([0,2,0,1,1,0])\n2-element Vector{Int64}:\n 2\n 4\n\njulia> argmaxima([2,0,1,1])\nInt64[]\n\njulia> argmaxima([2,0,1,1]; strict=false)\n2-element Vector{Int64}:\n 1\n 3\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peaks.argminima","page":"API","title":"Peaks.argminima","text":"argminima(x[, w=1; strict=false]) -> Vector{Int}\n\nFind the indices of local minima in x, where each minima i is either the minimum of x[i-w:i+w] or the first index of a plateau.\n\nA plateau is defined as a minima with consecutive equal (==) minimal values which are bounded by greater values immediately before and after the consecutive minimal values.\n\nWhen strict == true, no elements in x[i-w:i+w] may be missing or NaN, and the bounds of a plateau must exist. For strict == false, a minima is the minimum of all non-NaN or missing elements in x[i-w:i+w], and plateau bounds are assumed to exist (i.e. missing, NaN, or either end of the array, x[begin-1] or x[end+1], may be treated as the bounds of a plateau).\n\nSee also: findminima, findnextminima\n\nExamples\n\njulia> argminima([3,2,3,1,1,3])\n2-element Vector{Int64}:\n 2\n 4\n\njulia> argminima([2,3,1,1])\nInt64[]\n\njulia> argminima([2,3,1,1]; strict=false)\n2-element Vector{Int64}:\n 1\n 3\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peaks.maxima","page":"API","title":"Peaks.maxima","text":"maxima(x[, w=1; strict=true]) -> Vector{eltype(x)}\n\nFind the values of local maxima in x, where each maxima i is either the maximum of x[i-w:i+w] or the first index of a plateau.\n\nA plateau is defined as a maxima with consecutive equal (==) maximal values which are bounded by lesser values immediately before and after the consecutive maximal values.\n\nSee also: argmaxima, findnextmaxima, minima\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peaks.minima","page":"API","title":"Peaks.minima","text":"minima(x[, w=1; strict=true]) -> Vector{eltype(x)}\n\nFind the values of local minima in x, where each minima i is either the minimum of x[i-w:i+w] or the first index of a plateau.\n\nA plateau is defined as a minima with consecutive equal (==) minimal values which are bounded by greater values immediately before and after the consecutive minimal values.\n\nSee also: argminima, findnextminima\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peaks.findmaxima","page":"API","title":"Peaks.findmaxima","text":"findmaxima(x[, w=1; strict=true]) -> (;indices, heights, data)\n\nFind the indices and values of local maxima in x, where each maxima i is either the maximum of x[i-w:i+w] or the first index of a plateau.\n\nReturns a NamedTuple contains the fields indices, heights, data, which are equivalent to heights = data[indices]. The data field is a reference (not a copy) to the argument x.\n\nA plateau is defined as a maxima with consecutive equal (==) maximal values which are bounded by lesser values immediately before and after the consecutive maximal values.\n\nSee also: argmaxima, findnextmaxima, findminima\n\nExamples\n\njulia> data = [1, 5, 1, 3, 2];\n\njulia> pks = findmaxima(data)\n(indices = [2, 4], heights = [5, 3], data = [1, 5, 1, 3, 2])\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peaks.findminima","page":"API","title":"Peaks.findminima","text":"findminima(x[, w=1; strict=true]) -> (;indices, heights, data)\n\nFind the indices and values of local minima in x, where each minima i is either the minimum of x[i-w:i+w] or the first index of a plateau.\n\nReturns a NamedTuple contains the fields indices, heights, data, which are equivalent to heights = data[indices]. The data field is a reference (not a copy) to the argument x.\n\nA plateau is defined as a minima with consecutive equal (==) minimal values which are bounded by greater values immediately before and after the consecutive minimal values.\n\nSee also: argminima, findnextminima\n\nExamples\n\njulia> data = [1, 5, 1, 3, 2];\n\njulia> valleys = findminima(data)\n(indices = [3], heights = [1], data = [1, 5, 1, 3, 2])\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peaks.simplemaxima","page":"API","title":"Peaks.simplemaxima","text":"simplemaxima(x) -> Vector{Int}\n\nFind the indices of local maxima in x, where each maxima i is greater than both adjacent elements or is the first index of a plateau.\n\nA plateau is defined as a maxima with consecutive equal (==) maximal values which are bounded by lesser values immediately before and after the plateau.\n\nThis function is semantically equivalent to argmaxima(x, w=1; strict=true), but is faster because of its simplified set of features. (The difference in speed scales with length(x); for input arrays longer than 5k elements, argmaxima is roughly 7x slower.)\n\nVectors with missings are not supported by simplemaxima, use argmaxima if this is needed.\n\nSee also: argmaxima\n\nExamples\n\njulia> simplemaxima([0,2,0,1,1,0])\n2-element Vector{Int64}:\n 2\n 4\n\njulia> argmaxima([0,2,0,1,1,0])\n2-element Vector{Int64}:\n 2\n 4\n\njulia> simplemaxima([2,0,1,1])\nInt64[]\n\njulia> @btime simplemaxima(x) setup=(x = repeat([0,1]; outer=100));\n  269.865 ns (3 allocations: 1.00 KiB)\n\njulia> @btime argmaxima(x) setup=(x = repeat([0,1]; outer=100));\n  748.780 ns (3 allocations: 1.00 KiB)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peaks.simpleminima","page":"API","title":"Peaks.simpleminima","text":"simpleminima(x) -> Vector{Int}\n\nFind the indices of local minima in x, where each minima i is less than both adjacent elements or is the first index of a plateau.\n\nA plateau is defined as a minima with consecutive equal (==) minimal values which are bounded by greater values immediately before and after the plateau.\n\nThis function is semantically equivalent to argminima(x, w=1; strict=true), but is faster because of its simplified set of features. (The difference in speed scales with length(x); for input arrays longer than 5k elements, argmaxima is roughly 7x slower.)\n\nVectors with missings are not supported by simpleminima, use argminima if this is needed.\n\nSee also: argminima\n\nExamples\n\njulia> simpleminima([3,2,3,1,1,3])\n2-element Vector{Int64}:\n 2\n 4\n\njulia> argminima([3,2,3,1,1,3])\n2-element Vector{Int64}:\n 2\n 4\n\njulia> simpleminima([2,3,1,1])\nInt64[]\n\njulia> @btime simpleminima(x) setup=(x = repeat([0,1]; outer=100));\n  280.362 ns (3 allocations: 1.00 KiB)\n\njulia> @btime argminima(x) setup=(x = repeat([0,1]; outer=100));\n  823.634 ns (3 allocations: 1.00 KiB)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peak-characteristics-and-filtering","page":"API","title":"Peak characteristics & filtering","text":"","category":"section"},{"location":"reference/","page":"API","title":"API","text":"peakproms\npeakproms!\npeakwidths\npeakwidths!\npeakheights\npeakheights!\nfilterpeaks!","category":"page"},{"location":"reference/#Peaks.peakproms","page":"API","title":"Peaks.peakproms","text":"peakproms(indices, x; [strict=true, min, max]) -> (indices, proms)\npeakproms(pks::NamedTuple; [strict=true, min, max]) -> NamedTuple\n\nCalculate the prominences of peak indices in x, and remove peaks with prominences less than min and/or greater than max.\n\nPeak prominence is the absolute height (value) difference between the current peak and the larger of the two adjacent smallest magnitude points between the current peak and adjacent larger peaks or signal ends.\n\nIf a NamedTuple pks is given, a new NamedTuple is returned with filtered copies of fields from pks. pks must have :indices and :heights fields. If pks has a :proms field, prominences will only be filtered, and not be recalculated. The fields :widths and :edges will also be filtered if present, and any remaining fields will be copied unmodified.\n\nIf strict == true, the prominence for a peak with a NaN or missing between the current peak and either adjacent larger peaks will be NaN or missing, otherwise, it will be the larger of the smallest non-NaN or missing values between the current peak and adjacent larger peaks for strict == false.\n\nSee also: peakproms!, findmaxima\n\nExamples\n\njulia> pks = findmaxima([0,5,2,3,3,1,4,0]);\n\njulia> pks = peakproms(pks; min=2)\n(indices = [2, 7], heights = [5, 4], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[5, 3])\n\njulia> inds, proms = peakproms(pks.indices, pks.data; max=4)\n([7], Union{Missing, Int64}[3])\n\n\n\n\n\npeakproms(; [strict, min, max]) -> Function\n\nCreate a function, f(pks::NamedTuple), that calculates and filters the peak prominences of a copy of its argument, pks, using any given keyword arguments.\n\nExamples\n\njulia> findmaxima([0,5,2,3,3,1,4,0]) |> peakproms(; min=2)\n(indices = [2, 7], heights = [5, 4], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[5, 3])\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peaks.peakproms!","page":"API","title":"Peaks.peakproms!","text":"peakproms!(indices, x; [strict=true, min, max]) -> (indices, proms)\npeakproms!(pks::NamedTuple; [strict=true, min, max]) -> NamedTuple\n\nCalculate the prominences of peak indices in x, and remove peaks with prominences less than min and/or greater than max.\n\nIf a NamedTuple pks is given, a new NamedTuple is returned with the same fields (references) from pks. pks must have :indices and :heights fields. If pks has a :proms field, prominences will only be filtered, and not be recalculated. The fields :widths and :edges will also be filtered (mutated) if present, and any remaining fields will be copied unmodified.\n\nSee also: peakproms, findmaxima\n\n\n\nExamples\n\njulia> pks = findmaxima([0,5,2,3,3,1,4,0]);\n\njulia> pks = peakproms!(pks; min=2)\n(indices = [2, 7], heights = [5, 4], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[5, 3])\n\njulia> inds, proms = peakproms!(pks.indices, pks.data; max=4)\n([7], Union{Missing, Int64}[3])\n\n\n\n\n\npeakproms!(; [strict, min, max]) -> Function\n\nCreate a function, f(pks::NamedTuple), that calculates and filters (mutates) the peak prominences and other fields of its argument, pks, using any given keyword arguments.\n\nExamples\n\njulia> findmaxima([0,5,2,3,3,1,4,0]) |> peakproms!(; min=2)\n(indices = [2, 7], heights = [5, 4], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[5, 3])\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peaks.peakwidths","page":"API","title":"Peaks.peakwidths","text":"peakwidths(indices, x, proms; [strict=true, relheight=0.5, min, max]) -> (indices, widths, ledge, redge)\npeakwidths(pks::NamedTuple; [strict=true, relheight=0.5, min, max]) -> NamedTuple\n\nCalculate the widths of peak indices in x at a reference level based on proms and relheight, and removing peaks with widths less than min and/or greater than max. Returns the peaks, widths, and the left and right edges at the reference level.\n\nPeak width is the distance between the signal crossing a reference level before and after the peak. Signal crossings are linearly interpolated between indices. The reference level is the difference between the peak height and relheight times the peak prominence. Width cannot be calculated for a NaN or missing prominence.\n\nIf a NamedTuple pks is given, a new NamedTuple is returned with filtered copies of fields from pks. pks must have :indices, :heights, and :proms fields. If pks has :widths and :edges fields, they will not be recalculated, but filtered only. Any remaining fields will be copied unmodified.\n\nIf strict == true, the width for a peak with a gap in the signal (e.g. NaN, missing) at the reference level will match the gap (e.g. NaN for NaN, etc.). Otherwise, the signal crossing will be linearly interpolated between the edges of the gap.\n\nSee also: peakwidths!, peakproms, findmaxima\n\nExamples\n\njulia> x = Float64[0,5,2,2,3,3,1,4,0];\n\njulia> pks = findmaxima(x) |> peakproms!(;max=2);\n\njulia> peakwidths(pks)\n(indices = [5], heights = [3.0], data = [0.0, 5.0, 2.0, 2.0, 3.0, 3.0, 1.0, 4.0, 0.0], proms = [1.0], widths = [1.75], edges = [(4.5, 6.25)])\n\njulia> x[4] = NaN;\n\njulia> peakwidths(pks.indices, x, pks.proms)\n([5], [NaN], [NaN], [6.25])\n\njulia> peakwidths(pks.indices, x, pks.proms; strict=false)\n([5], [2.25], [4.0], [6.25])\n\n\n\n\n\npeakwidths(; [strict, relheight, min, max]) -> Function\n\nCreate a function, f(pks::NamedTuple), that calculates and filters the peak widths of a copy of its argument, pks, using any given keyword arguments.\n\nExamples\n\njulia> findmaxima([0,5,2,3,3,1,4,0]) |> peakproms() |> peakwidths(; min=1.5)\n(indices = [4], heights = [3], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[1], widths = Union{Missing, Float64}[1.75], edges = Tuple{Union{Missing, Float64}, Union{Missing, Float64}}[(3.5, 5.25)])\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peaks.peakwidths!","page":"API","title":"Peaks.peakwidths!","text":"peakwidths!(indices, x; [strict=true, relheight=0.5, min, max]) -> (indices, widths, ledge, redge)\npeakwidths!(pks::NamedTuple; [strict=true, relheight=0.5, min, max]) -> NamedTuple\n\nCalculate the widths of peak indices in x at a reference level based on proms and relheight, removing peaks with widths less than min and/or greater than max. Returns the modified peaks, widths, and the left and right edges at the reference level.\n\nIf a NamedTuple pks is given, a new NamedTuple is returned with the same fields (references) from pks. pks must have :indices, :heights, and :proms fields. If pks has :widths and :edges fields, they will not be recalculated, but filtered only. Any remaining fields will be copied unmodified.\n\nSee also: peakwidths, peakproms, findmaxima\n\n\n\nExamples\n\njulia> x = Float64[0,5,2,2,3,3,1,4,0];\n\njulia> pks = findmaxima(x) |> peakproms!();\n\njulia> peakwidths!(pks; min=1)\n(indices = [2, 5], heights = [5.0, 3.0], data = [0.0, 5.0, 2.0, 2.0, 3.0, 3.0, 1.0, 4.0, 0.0], proms = [5.0, 1.0], widths = [1.333, 1.75], edges = [(1.5, 2.833), (4.5, 6.25)])\n\njulia> peakwidths!(pks.indices, pks.data, pks.proms; min=1)\n([2, 5], [1.333, 1.75], [1.5, 4.5], [2.833, 6.25])\n\n\n\n\n\npeakwidths!(; [strict, relheight, min, max]) -> Function\n\nCreate a function, f(pks::NamedTuple), that calculates and filters (mutates) the peak widths and other fields of its argument, pks, using any given keyword arguments.\n\nExamples\n\njulia> findmaxima([0,5,2,3,3,1,4,0]) |> peakproms!() |> peakwidths!(; min=1.5)\n(indices = [4], heights = [3], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[1], widths = Union{Missing, Float64}[1.75], edges = Tuple{Union{Missing, Float64}, Union{Missing, Float64}}[(3.5, 5.25)])\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peaks.peakheights","page":"API","title":"Peaks.peakheights","text":"peakheights(indices, heights; [min, max]) -> (indices, heights)\npeakheights(pks::NamedTuple; [min, max]) -> NamedTuple\n\nReturn a copy of indices and heights where peaks are removed if their height is less than min and/or greater than max.\n\nIf a NamedTuple pks is given, a new NamedTuple is returned with filtered copies of fields from pks. pks must have :indices and :heights fields. The fields :proms, :widths, and :edges will be filtered if present, and any remaining fields will be copied unmodified.\n\nSee also: peakproms, peakwidths, findmaxima\n\nExamples\n\njulia> x = [0,5,2,3,3,1,4,0];\n\njulia> pks = findmaxima(x)\n(indices = [2, 4, 7], heights = [5, 3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\njulia> peakheights(pks; max=4)\n(indices = [4, 7], heights = [3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\njulia> inds, heights = peakheights(pks.indices, pks.heights; max=4)\n([4, 7], [3, 4])\n\n\n\n\n\npeakheights(; [min, max]) -> Function\n\nCreate a function, f(pks::NamedTuple), that copies and filters the peak heights of its argument, pks, using any given keyword arguments.\n\nExamples\n\njulia> findmaxima([0, 5, 2, 3, 3, 1, 4, 0]) |> peakheights(; max=4)\n(indices = [4, 7], heights = [3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peaks.peakheights!","page":"API","title":"Peaks.peakheights!","text":"peakheights!(indices, heights; [min, max]) -> (indices, heights)\npeakheights!(pks::NamedTuple; [min, max]) -> NamedTuple\n\nFilter (mutate) and return indices and heights by removing peaks that are less than min and/or greater than max.\n\nIf a NamedTuple pks is given, a new NamedTuple is returned with the same fields (references) from pks. pks must have :indices and :heights fields. The fields :proms, :widths, and :edges will be filtered (mutated) if present, and any remaining fields will be referenced unmodified.\n\nSee also: peakproms, peakwidths, findmaxima filterpeaks!\n\nExamples\n\njulia> x = [0,5,2,3,3,1,4,0];\n\njulia> pks = findmaxima(x)\n(indices = [2, 4, 7], heights = [5, 3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\njulia> peakheights!(pks; max=4)\n(indices = [4, 7], heights = [3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\njulia> inds, heights = peakheights!(pks.indices, pks.heights; min=3.5)\n([7], [4])\n\n\n\n\n\npeakheights!(; [min, max]) -> Function\n\nCreate a function, f(pks::NamedTuple), that calculates peak heights and then filters (mutates) the fields of its argument, pks, using any given keyword arguments.\n\nExamples\n\njulia> findmaxima([0, 5, 2, 3, 3, 1, 4, 0]) |> peakheights!(; max=4)\n(indices = [4, 7], heights = [3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peaks.filterpeaks!","page":"API","title":"Peaks.filterpeaks!","text":"filterpeaks!(pks::NT, feature; [min, max]) where {NT<:NamedTuple} -> pks::NT\nfilterpeaks!(pks::NT, mask) -> pks::NT\n\nFilter the standard pks fields where peaks are removed if pks.$feature is less than min and/or greater than max. If a mask is given, a given peak i is filtered (removed) if mask[i] is false.\n\nStandard Peaks.jl fields of pks are :indices, :proms, :heights, :widths, :edges.\n\nExamples\n\njulia> pks = findmaxima([0,5,2,3,3,1,4,0])\n(indices = [2, 4, 7], heights = [5, 3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\njulia> filterpeaks!(pks, :heights; max=4)\n(indices = [4, 7], heights = [3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\njulia> pks = findmaxima([0,5,2,3,3,1,4,0]) |> peakproms!();\n\njulia> mask = [pks.heights[i] < 5 &&  pks.proms[i] > 2 for i in eachindex(pks.indices)]\n3-element Vector{Bool}:\n 0\n 0\n 1\n\njulia> filterpeaks!(pks, mask)\n(indices = [7], heights = [4], data = [0, 5, 2, 3, 3, 1, 4, 0], proms = Union{Missing, Int64}[3])\n\n\n\n\n\nfilterpeaks!(pred, pks) -> NamedTuple\n\nApply a predicate function pred to NamedTuple slices (the scalar values related to each peak, e.g. (indices=5, heights=3, proms=2)) to and remove a peak if pred returns false.\n\nExamples\n\njulia> pks = findmaxima([0,5,2,3,3,1,4,0])\n(indices = [2, 4, 7], heights = [5, 3, 4], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\njulia> filterpeaks!(pks) do nt\n           return nt.heights ≥ 5 || nt.heights ≤ 3\n       end\n(indices = [2, 4], heights = [5, 3], data = [0, 5, 2, 3, 3, 1, 4, 0])\n\n\n\n\n\n","category":"function"},{"location":"reference/#Convenience-functions","page":"API","title":"Convenience functions","text":"","category":"section"},{"location":"reference/","page":"API","title":"API","text":"findnextmaxima\nfindnextminima\nismaxima\nisminima\nisplateau","category":"page"},{"location":"reference/#Peaks.findnextmaxima","page":"API","title":"Peaks.findnextmaxima","text":"findnextmaxima(x, i[, w=1; strict=true]) -> Int\n\nFind the index of the next maxima in x after or including i, where the maxima i is either the maximum of x[i-w:i+w] or the first index of a plateau. Returns lastindex(x) + 1 if no maxima occur after i.\n\nA plateau is defined as a maxima with consecutive equal (==) maximal values which are bounded by lesser values immediately before and after the consecutive maximal values.\n\nWhen strict == true, no elements in x[i-w:i+w] may be missing or NaN, and the bounds of a plateau must exist. For strict == false, a maxima is the maximum of all non-NaN or missing elements in x[i-w:i+w], and plateau bounds are assumed to exist (i.e. missing, NaN, or either end of the array, x[begin-1] or x[end+1], may be treated as the bounds of a plateau).\n\nSee also: argmaxima\n\nExamples\n\njulia> findnextmaxima([0,2,0,1,1,0], 2)\n2\n\njulia> findnextmaxima([0,2,0,1,1,0], 3)\n4\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peaks.findnextminima","page":"API","title":"Peaks.findnextminima","text":"findnextminima(x, i[, w=1, strict=true]) -> Int\n\nFind the index of the next minima in x, after or including i, where the minima i is either the minimum of x[i-w:i+w] or the first index of a plateau. Returns lastindex(x) + 1 if no minima occur after i.\n\nA plateau is defined as a minima with consecutive equal (==) minimal values which are bounded by greater values immediately before and after the consecutive minimal values.\n\nWhen strict == true, no elements in x[i-w:i+w] may be missing or NaN, and the bounds of a plateau must exist. For strict == false, a minima is the minimum of all non-NaN or missing elements in x[i-w:i+w], and plateau bounds are assumed to exist (i.e. missing, NaN, or either end of the array, x[begin-1] or x[end+1], may be treated as the bounds of a plateau).\n\nSee also: argminima\n\nExamples\n\njulia> findnextminima([3,2,3,1,1,3], 2)\n2\n\njulia> findnextminima([3,2,3,1,1,3], 3)\n4\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peaks.ismaxima","page":"API","title":"Peaks.ismaxima","text":"ismaxima(i, x[, w=1; strict=true]) -> Bool\n\nTest if i is a maxima in x, where the maxima i is either the maximum of x[i-w:i+w] or the first index of a plateau.\n\nA plateau is defined as a maxima with consecutive equal (==) maximal values which are bounded by lesser values immediately before and after the consecutive maximal values.\n\nSee also: findnextmaxima\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peaks.isminima","page":"API","title":"Peaks.isminima","text":"isminima(i, x[, w=1; strict=true]) -> Bool\n\nTest if i is a minima in x, where the minima i is either the minimum of x[i-w:i+w] or the first index of a plateau.\n\nA plateau is defined as a minima with consecutive equal (==) minimal values which are bounded by greater values immediately before and after the consecutive minimal values.\n\nSee also: findnextminima\n\n\n\n\n\n","category":"function"},{"location":"reference/#Peaks.isplateau","page":"API","title":"Peaks.isplateau","text":"isplateau(i, x[, w=1; strict=true]) -> Union{Missing,Bool}\n\nTest if i is a plateau in x, where a plateau is defined as a maxima or minima with consecutive equal (==) extreme values which are bounded by lesser values immediately before and after the consecutive values. Returns false if i is the last index in x.\n\nSee also: ismaxima, isminima\n\n\n\n\n\n","category":"function"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"include(\"plots/peak-animation.jl\")","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"include(\"plots/height.jl\")","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"include(\"plots/prominence-animation.jl\")","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"include(\"plots/plateau.jl\")","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"include(\"plots/width.jl\")","category":"page"},{"location":"glossary/#Common-terminology","page":"Glossary","title":"Common terminology","text":"","category":"section"},{"location":"glossary/#Prefixes-and-suffixes","page":"Glossary","title":"Prefixes and suffixes","text":"","category":"section"},{"location":"glossary/#\"Maxim-\",-\"minim-\",-\"extrem-\"-prefixes","page":"Glossary","title":"\"Maxim-\", \"minim-\", \"extrem-\" prefixes","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"\"Maxim-\" refer to large/larger/etc\n\"Minim-\" refer to little/small/smaller/etc\n\"Extrem-\" refer to both large and small","category":"page"},{"location":"glossary/#\"-a\",-\"-um\"-suffixes","page":"Glossary","title":"\"-a\", \"-um\" suffixes","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The \"-a\" suffix (e.g. \"maxima\") means \"of a part [of the data]\"; there can be multiple maxima in a vector (or a part of a vector)\nThe \"-um\" suffix (e.g. \"maximum\") means \"of the whole [data]\"; there can only be one maximum in a vector (or a part of a vector)","category":"page"},{"location":"glossary/#Peaks-and-characteristics","page":"Glossary","title":"Peaks and characteristics","text":"","category":"section"},{"location":"glossary/#peak","page":"Glossary","title":"Peak (a.k.a. [local] extrema, maxima, minima, etc.)","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Maxima and minima refer to the maximum or minimum (respectively) value within a window, and peak or extrema refers to both maxima and/or minima.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"More technically, a peak is an element x[i] which is more extreme (i.e. larger or smaller) than all elements in the window x[i-w:i+w] where w is a positive integer. The simplest and most common case is w=1, which results in an element being more extreme than its neighbors.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"In the animation below, the maximum in the window x[i-w:i+w] (grey band) is shown as the purple dot. When the maximum lines up with the current \"time\" (i.e. index, vertical black line), a peak is identified (red dot). Use the scroll bar at the bottom to understand why some \"peaks\" aren't found. (Hint: pay attention the window size and the window maximum.)","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"INCLUDE_PLOTLYJS[] = \"require\" # hide\nPlotForceHTML(p) # hide","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"note: Note\nIn this package/documentation, \"peak\" is often used when referring to the index (i.e. location) of a peak, which is most broadly relevant when speaking of a specific peak","category":"page"},{"location":"glossary/#Plateau","page":"Glossary","title":"Plateau","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A \"flat\" peak, where the value of the extrema occurs multiple times consecutively, but surrounding elements are less than the extremum. The first occurence of the extrema is considered the peak location. Uncommon for floating-point data.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"p # hide","category":"page"},{"location":"glossary/#height","page":"Glossary","title":"Peak height","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Peak height is the value of the signal for a specific peak. Mouse over (or touch) each peak to see its height.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"PlotForceHTML(p) # hide","category":"page"},{"location":"glossary/#prominence","page":"Glossary","title":"Peak prominence","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"For maxima, peak prominence is the (absolute) difference between the height of a maxima and the larger of the two minimums in the adjacent reference ranges. Reference ranges cover the data between the current maxima and adjacent (i.e. previous and next) reference maxima, which must be at least as large as the current maxima, or the beginning/end of the array. The same is true of minima with opposite extrema/extremum (e.g. minima for maxima, and maximum for minimum, etc.).","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"PlotForceHTML(p) # hide","category":"page"},{"location":"glossary/#width","page":"Glossary","title":"Peak width","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Peak width is measured as the distance (in units of indices) between the intersection of a horizontal reference line with the signal on either side of a peak, where the height of the reference line is offset from the peak height by a proportion of the peak prominence (keyword argument relheight for the peakwidths functions).","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"p # hide","category":"page"},{"location":"glossary/#strict","page":"Glossary","title":"\"Strict\"-ness","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The default behavior of peak finding and related functions (e.g. peakproms, etc.) is to only return results that are exactly correct, and to return nothing (i.e. ignore a potential peak), NaN, or missing, as appropriate for a given function. This behavior is controlled by the strict keyword argument (true by default). Setting the strict keyword to false allows these functions to relax some requirements. When strict == false, functions will make optimistic assumptions in an attempt to return useful information (e.g. something not NaN or missing) when data violates default requirements. This can produce results that are not correct according to the strictest definitions of peaks and their characteristics, however, sometimes relaxed behavior is desired/needed.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"strict-ness should only affect new peaks/characteristics (i.e. only peaks detected with strict == false). Any observed behavior otherwise (i.e. characteristics of non-strict peaks are altered) is undesired[1] and an issue should be opened.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"[1]: We try to ensure that characteristics of non-strict peak will be unaffected during strict == false mode. Any issues with examples of altered characteristics are appreciated, and fixes will be attempted, but we do not guarantee that altered peak characteristics can be prevented.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"warning: List of Peaks.jl function behavior/assumptions for `strict == false`\nmaxima/minima finding functions (e.g. findmaxima, etc.) assume that any unobserved (e.g. missing or due to the beginning/end of the array) or NaN data in a window is consistent with a peak. For example:\nThe maximal/minimal value in an incomplete window (e.g. an index i within w elements of the array beginning or end, i-w < firstindex(x) or i+w > lastindex(x)) is assumed to be a peak (i.e. if the array continued, the data would be less/more the current maximal/minimal value). This allows the first or last elements of an array to be considered peaks if the data in the window is ascending or descending.\nThe maximal/minimal value in a window containing missing or NaN elements is assumed to be a peak (i.e. the missing or NaN values would be less/more than the current value if they existed or were real numbers)\npeakproms uses the larger present (i.e. not NaN or missing) value of the minimum values in each reference range (see prominence definition)\npeakwidths linearly interpolates across a gap at the width reference level","category":"page"},{"location":"#Peaks.jl","page":"Home","title":"Peaks.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Peaks.jl is a library for finding peaks (i.e. local maxima and minima) and peak characteristics (e.g. how prominent or wide are peaks, etc) in vector (1D) data signals.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Peaks.jl can be installed from the Julia REPL by running","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add Peaks","category":"page"},{"location":"","page":"Home","title":"Home","text":"mktempdir() do tmpdir # hide\n    out = read(`julia --color=yes -e \" # hide\n        using Pkg; # hide\n        redirect_stderr(devnull) # hide\n        Pkg.activate(\\\"$tmpdir\\\"); # hide\n        redirect_stderr(stdout) # hide\n        Pkg.add(\\\"Peaks\\\");\"`, String); # hide\n    out = replace(out, tmpdir => \"~/.julia/environments/v$(VERSION.major).$(VERSION.minor)\") # hide\n    print(out); # hide\nend; # hide","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"#Finding-peaks","page":"Home","title":"Finding peaks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Peaks, Plots; gr()\n\nT = 1/25\nt = 0:T:23\n\nf(t) = 3sinpi(0.1t) + 2sinpi(0.2t) + sinpi(0.6t)\n\ny = f.(t);","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = plot(t, y; label=\"signal\") # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"To find the peaks in your data you can use the findmaxima function, which returns a NamedTuple with fields for each calculated peak characteristic (indices, heights) and a reference to the data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"indices, heights = findmaxima(y)","category":"page"},{"location":"","page":"Home","title":"Home","text":"When the peaks are plotted over the data, we see that all the local maxima have been identified.","category":"page"},{"location":"","page":"Home","title":"Home","text":"plot!(p, t[indices], heights; seriestype=:scatter, label=\"maxima\") # hide","category":"page"},{"location":"#Peak-characteristics","page":"Home","title":"Peak characteristics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Peaks have various characteristics, including height, prominence, and width. Peaks.jl exports functions for finding each characteristic: peakheights, peakproms, peakwidths:","category":"page"},{"location":"","page":"Home","title":"Home","text":"indices, proms = peakproms(indices, y)\n\nindices, widths, edges... = peakwidths(indices, y, proms)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Mutating bang ('!') functions are available (i.e. peakproms!, etc.) when allocations are a concern.","category":"page"},{"location":"#Peaks-NamedTuple-and-pipable-API","page":"Home","title":"Peaks NamedTuple & pipable API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are Peaks.jl functions that bundle the peaks, peak characteristics, and signal into a convenient NamedTuple:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pks = findmaxima(y);\npks = peakproms(pks);\npks = peakwidths(pks)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Mutating functions are also available for the NamedTuple functions; the vectors within the NamedTuple are mutated and re-used in the returned tuple. The NamedTuple functions can also be chained/piped:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pks = findmaxima(y) |> peakproms!(;strict=false) |> peakwidths!(; max=100)","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Performance tip\nBe aware that the NamedTuple functions allocate more memory than the functions with direct/explicit arguments. If maximum performance is needed, mutating functions (e.g. peakproms!, etc) and/or the direct, non-NamedTuple methods are a better choice.","category":"page"},{"location":"#Plotting","page":"Home","title":"Plotting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The peaks, prominences, and widths can be visualized all together using a Plots.jl recipe plotpeaks:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\nplotpeaks(t, y; peaks=indices, prominences=true, widths=true)","category":"page"}]
}
